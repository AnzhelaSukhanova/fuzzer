package com.stepanov.bbf.bugfinder

import com.stepanov.bbf.bugfinder.executor.project.Project
import com.stepanov.bbf.bugfinder.util.*
import java.io.File

class SingleFileBugFinder(dir: String) : BugFinder(dir) {

    fun findBugsInFile() {
        try {
            println("Let's go")
            ++counter
            log.debug("Name = $dir")
//            val psiCreator = PSICreator("")
//            val psiFile =
//                try {
//                    psiCreator.getPSIForFile(dir)
//                } catch (e: Throwable) {
//                    println("e = $e")
//                    return
//                }
//            if (psiFile.text.contains("// Auto-generated by")) {
//                log.debug("Auto-generated")
//            }
            val project = Project.createFromCode(File(dir).readText())
            if (project.files.isEmpty()) {
                log.debug("Cant create project")
                return
            }
            val compilersConf = BBFProperties.getStringGroupWithoutQuotes("BACKENDS")
            val filterBackends = compilersConf.map { it.key }
            if (filterBackends.any { project.isBackendIgnores(it) }) {
                //TODO disable?
                log.debug("Ignore some of backends")
            }
//            val ignoreBackendsFromFile =
//                psiFile.text.lineSequence()
//                    .filter { it.startsWith("// IGNORE_BACKEND:") }
//                    .map { it.substringAfter("// IGNORE_BACKEND:") }
//                    .map { it.split(",") }
//                    .flatten()
//                    .map { it.trim() }
//                    .toList()
//            if (ignoreBackendsFromFile.any { filterBackends.contains(it) }) {
//                log.debug("Skipped because one of the backends is ignoring")
//                return
//            }
//            if (psiFile.getAllPSIChildrenOfType<KtNamedFunction>().all { it.name?.contains("box") == false }) return

            if (compilers.any { !it.checkCompiling(project) }) {
                log.debug("Could not compile $dir")
                return
            }
            log.debug("Start to mutate")
            val resultingMutant = makeMutant(project, project.files.first(), listOf(::noBoxFunModifying))

            if (!compilers.checkCompilingForAllBackends(resultingMutant)) {
                log.debug("Could not compile after mutation $dir")
                log.debug(resultingMutant.text)
                System.exit(1)
            }
            log.debug("Mutated = ${resultingMutant.text}")

//            //Save mutated file
//            if (CompilerArgs.shouldSaveMutatedFiles) {
//                val pathToNewTests = CompilerArgs.dirForNewTests
//                File(pathToNewTests).mkdirs()
//                val pathToSave = "$pathToNewTests/${Random().getRandomVariableName(10)}.kt"
//                File(pathToSave).writeText(resultingMutant.text)
//            }
//
//            val checker = MutationChecker(compilers)
//            //Now begin to trace mutated file
//            val tracer = Tracer(resultingMutant, psiCreator.ctx!!, checker)
//            val traced = tracer.trace()
//            log.debug("Traced = ${traced.text}")
//            if (!compilers.checkCompilingForAllBackends(traced)) {
//                log.debug("Could not compile after tracing $dir")
//                log.debug(traced.text)
//            }
//            //Check diff beh with no-optimizing
//            compilers.add(JVMCompiler("-Xno-optimize"))
//            val res = TracesChecker(compilers).checkTest(traced.text)
//            log.debug("Result = $res")
//            //Save into tmp file and reduce
//            if (res != null) {
//                File(CompilerArgs.pathToTmpFile).writeText(traced.text)
////                val reduced =
////                        if (CompilerArgs.shouldReduceDiffBehavior)
////                            Reducer.reduceDiffBehavior(
////                                CompilerArgs.pathToTmpFile,
////                                compilers
////                            )
////                        else
////                            traced.text
//               // BugManager.saveBug(res, "", Project.createFromCode(traced.text), BugType.DIFFBEHAVIOR)
//            }
            return
        } catch (e: Error) {
            println("ERROR: $e")
            log.debug("ERROR: $e")
            return
            //System.exit(0)
        }
    }

    var counter = 0
}